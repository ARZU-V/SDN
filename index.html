<!DOCTYPE html>
<html lang="en">
<head>
    <title>SDN-VR Command Center</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background-color: #000; color: #00ffff; font-family: 'Orbitron', sans-serif; overflow: hidden; }
        
        /* UI Layer */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
            justify-content: space-between; align-items: center;
            padding: 20px; box-sizing: border-box; z-index: 10;
        }

        #status-bar {
            background: rgba(0, 20, 40, 0.9); border: 1px solid #00ffff;
            padding: 15px 40px; border-radius: 0 0 20px 20px;
            text-align: center; pointer-events: auto;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        /* AI Caption Box */
        #caption-box { margin-top: 10px; font-size: 14px; color: #ffffff; text-shadow: 0 0 5px cyan; }

        #controls { display: flex; gap: 30px; pointer-events: auto; margin-bottom: 120px; }

        .cyber-btn {
            background: rgba(0, 0, 0, 0.9); border: 2px solid #00ffff; color: #00ffff;
            padding: 15px 30px; font-family: 'Orbitron', sans-serif; font-size: 14px;
            font-weight: bold; text-transform: uppercase; cursor: pointer;
            border-radius: 4px; box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
            min-width: 180px;
        }
        .cyber-btn.active { background: #00ffff; color: #000; box-shadow: 0 0 35px rgba(0, 255, 255, 1); }

        /* VR Button Container */
        #vr-button-container {
            position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%);
            z-index: 9999; pointer-events: auto;
        }

        #loading-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 24px; color: #ffff00; z-index: 5; text-shadow: 0 0 10px yellow;
            display: block;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading-msg">LOADING ENV...</div>

    <div id="ui-layer">
        <div id="status-bar">
            <h2 style="margin:0; letter-spacing: 3px; text-shadow: 0 0 10px cyan;">SDN-VR TERMINAL</h2>
            <div id="conn-status" style="font-size: 12px; margin-top: 8px; color: #888;">INITIALIZING...</div>
            <div id="caption-box">WAITING FOR AI ANALYSIS...</div>
        </div>

        <!-- VLM PANEL -->
        <div id="ai-panel" style="position: absolute; right: 30px; top: 50%; transform: translateY(-50%); width: 300px; background: rgba(0, 10, 20, 0.9); border: 1px solid #00ffff; border-radius: 10px; pointer-events: auto;">
            <div style="padding: 10px; border-bottom: 1px solid #00ffff; text-align: center; font-weight: bold;">VLM ANALYSIS LOG</div>
            <div id="ai-log" style="height: 300px; overflow-y: auto; padding: 10px; font-family: monospace; font-size: 12px; color: #aaddff;">
                <div class="log-entry">SYSTEM READY...</div>
            </div>
        </div>

        <div id="controls">
            <button id="btn-seg" class="cyber-btn active" onclick="window.setMode('segmentation')">Segmentation</button>
            <button id="btn-det" class="cyber-btn" onclick="window.setMode('detection')">Object Detection</button>
        </div>
    </div>

    <div id="vr-button-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory.js';

        // --- CONFIG ---
        const YOUR_PC_IP = window.location.hostname; 
        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const WS_URL = `${protocol}://${YOUR_PC_IP}:8765`;
        const ROOM_SCALE = 1.0; 

        let scene, camera, renderer, ws;
        let videoTexture;
        let controllers = [];
        let teleportGroup;
        let raycaster, marker;
        let lastCaption = "";
        
        // --- INTERACTION GLOBALS ---
        let grabbableObjects = [];
        let tempMatrix = new THREE.Matrix4();
        let selectionBox; 

        window.setMode = function(mode) {
            const btnSeg = document.getElementById('btn-seg');
            const btnDet = document.getElementById('btn-det');
            if(btnSeg && btnDet) {
                btnSeg.className = mode === 'segmentation' ? 'cyber-btn active' : 'cyber-btn';
                btnDet.className = mode === 'detection' ? 'cyber-btn active' : 'cyber-btn';
            }
            if(ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ "mode": mode }));
            }
        };

        function init() {
            // 1. Setup 3D Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510); 
            
            teleportGroup = new THREE.Group();
            scene.add(teleportGroup);
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
            teleportGroup.add(camera);
            teleportGroup.position.set(0, 0, 2); 

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(3, 10, 10);
            scene.add(dirLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // --- VR BUTTON ---
            const btn = VRButton.createButton(renderer);
            btn.style.cssText = `
                display: block !important;
                padding: 15px 40px; border: 2px solid #00ffff; border-radius: 0px;
                background: rgba(0,0,0,0.9); color: #00ffff; font-family: 'Orbitron', sans-serif;
                font-weight: bold; font-size: 16px; cursor: pointer; text-transform: uppercase;
                letter-spacing: 3px; box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            `;
            if (btn.innerHTML.includes("HTTPS")) {
                btn.style.borderColor = "#ff0000"; btn.style.color = "#ff0000";
                btn.style.boxShadow = "0 0 20px rgba(255, 0, 0, 0.4)";
            }
            document.getElementById('vr-button-container').appendChild(btn);

            // 2. Setup Video Texture
            const vCanvas = document.createElement('canvas');
            vCanvas.width = 640; vCanvas.height = 480;
            const vCtx = vCanvas.getContext('2d');
            vCtx.fillStyle = '#111'; vCtx.fillRect(0,0,640,480);
            vCtx.fillStyle = '#0ff'; vCtx.font = '30px Arial'; vCtx.textAlign='center'; 
            vCtx.fillText("WAITING FOR UPLINK...", 320, 240);
            
            videoTexture = new THREE.CanvasTexture(vCanvas);
            videoTexture.encoding = THREE.sRGBEncoding;

            connectWS(vCtx, vCanvas);
            
            selectionBox = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(1,1,1)), 0xffff00);
            selectionBox.visible = false;
            scene.add(selectionBox);

            // 3. Load Room Model
            const loader = new GLTFLoader();
            const loadingMsg = document.getElementById('loading-msg');
            loadingMsg.style.display = 'block';

            const loadTimeout = setTimeout(() => {
                console.warn("Model load timed out. Building fallback.");
                buildFallbackRoom();
            }, 2500);

            loader.load('futuristic_room.glb', (gltf) => {
                clearTimeout(loadTimeout);
                loadingMsg.style.display = 'none';
                const model = gltf.scene;
                model.scale.set(ROOM_SCALE, ROOM_SCALE, ROOM_SCALE);
                model.position.set(0, 0, 0); 
                
                let tvFound = false;
                model.traverse((child) => {
                    if (child.isMesh) {
                        if (child.name.toLowerCase().includes('tv') || child.name.toLowerCase().includes('screen')) {
                            child.material = new THREE.MeshBasicMaterial({ map: videoTexture });
                            grabbableObjects.push(child);
                            tvFound = true;
                        }
                        if (!child.material.map) {
                            child.material = new THREE.MeshStandardMaterial({color: 0xaaaaaa, roughness: 0.8});
                        }
                    }
                });

                // FIX: Only create floating screen if NO TV was found
                if (!tvFound) {
                    console.log("No TV found in model, creating floating screen.");
                    createFloatingScreen();
                }
                
                scene.add(model);

            }, undefined, (error) => {
                clearTimeout(loadTimeout);
                console.error("Error loading model:", error);
                buildFallbackRoom();
            });

            setupControllers();
            renderer.setAnimationLoop(render);
            window.addEventListener('resize', onResize);
        }

        function buildFallbackRoom() {
            document.getElementById('loading-msg').style.display = 'none';
            const grid = new THREE.GridHelper(50, 50, 0x00ffff, 0x111133);
            scene.add(grid);
            createFloatingScreen();
        }

        function createFloatingScreen() {
            // --- SIZE ADJUSTMENT ---
            // Reduced radius/height for a smaller, more "TV-like" screen
            const radius = 2.0; 
            const height = 1.2; 
            const angle = Math.PI / 4; // Narrower curve (45 degrees)
            
            const geometry = new THREE.CylinderGeometry(radius, radius, height, 32, 1, true, -angle/2, angle);
            geometry.scale(-1, 1, 1); 
            const material = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide });
            const screen = new THREE.Mesh(geometry, material);
            
            // Position: Centered, Eye Level, 2.0m away
            screen.position.set(0, 1.6, -2.0); 
            
            scene.add(screen);
            grabbableObjects.push(screen); 
        }

        function setupControllers() {
            marker = new THREE.Mesh(new THREE.RingGeometry(0.2, 0.25, 32).rotateX(-Math.PI/2), new THREE.MeshBasicMaterial({color: 0x00ffff}));
            scene.add(marker);
            raycaster = new THREE.Raycaster();
            const factory = new XRControllerModelFactory();
            for (let i = 0; i < 2; i++) {
                const c = renderer.xr.getController(i);
                c.userData = { isSelecting: false, heldObject: null };
                c.addEventListener('selectstart', onSelectStart);
                c.addEventListener('selectend', onSelectEnd);
                const g = renderer.xr.getControllerGrip(i);
                g.add(factory.createControllerModel(g));
                teleportGroup.add(g);
                const l = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-5)]), new THREE.LineBasicMaterial({ color: 0x00ffff }));
                l.name = 'line'; l.scale.z = 1;
                c.add(l);
                teleportGroup.add(c);
                controllers.push(c);
            }
        }

        function onSelectStart(event) {
            const controller = event.target;
            controller.userData.isSelecting = true;

            if (!controller.userData.heldObject) {
                tempMatrix.identity().extractRotation(controller.matrixWorld);
                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

                const intersects = raycaster.intersectObjects(grabbableObjects, true);
                if (intersects.length > 0) {
                    let objectToGrab = intersects[0].object;
                    while(objectToGrab.parent && !grabbableObjects.includes(objectToGrab) && objectToGrab.parent !== scene) {
                        objectToGrab = objectToGrab.parent;
                    }
                    controller.userData.heldObject = objectToGrab;
                    controller.attach(objectToGrab); 
                    const line = controller.getObjectByName('line');
                    if(line) line.material.color.setHex(0xff0000);
                }
            }
        }

        function onSelectEnd(event) {
            const controller = event.target;
            controller.userData.isSelecting = false;
            if (controller.userData.heldObject) {
                scene.attach(controller.userData.heldObject);
                controller.userData.heldObject = null;
                const line = controller.getObjectByName('line');
                if(line) line.material.color.setHex(0x00ffff);
            } else if (marker.visible) {
                teleportGroup.position.set(marker.position.x, teleportGroup.position.y, marker.position.z);
            }
        }

        function addLogEntry(text) {
            const logContainer = document.getElementById('ai-log');
            if(!logContainer) return;
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.style.marginBottom = "5px";
            entry.style.borderBottom = "1px solid rgba(0,255,255,0.2)";
            const time = new Date().toLocaleTimeString([], {hour12: false});
            entry.innerHTML = `<span style="color:#5aa; font-size:10px;">[${time}]</span> ${text}`;
            logContainer.prepend(entry); 
            if (logContainer.children.length > 20) logContainer.removeChild(logContainer.lastChild);
        }

        function connectWS(ctx, canvas) {
            const statusEl = document.getElementById('conn-status');
            const miniPreview = document.getElementById('mini-preview');
            ws = new WebSocket(WS_URL);
            ws.onopen = () => {
                statusEl.innerText = "SYSTEM ONLINE // SIGNAL LOCKED";
                statusEl.style.color = "#00ff00";
            };
            const img = new Image();
            img.onload = () => {
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                videoTexture.needsUpdate = true;
            };
            ws.onmessage = (e) => {
                try {
                    const data = JSON.parse(e.data);
                    if (data.image) {
                        img.src = "data:image/jpeg;base64," + data.image;
                    }
                    if (data.caption && data.caption !== lastCaption) {
                        lastCaption = data.caption;
                        document.getElementById('caption-box').innerText = "AI ANALYSIS: " + data.caption.toUpperCase();
                        addLogEntry(data.caption.toUpperCase());
                    }
                } catch (err) {
                    img.src = "data:image/jpeg;base64," + e.data;
                }
            };
            ws.onclose = () => {
                statusEl.innerText = "SEARCHING FOR UPLINK...";
                statusEl.style.color = "#ffff00";
                setTimeout(() => connectWS(ctx, canvas), 2000);
            };
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function render() {
            let intersecting = false;
            selectionBox.visible = false;
            for (const c of controllers) {
                const line = c.getObjectByName('line');
                if (c.userData.heldObject) {
                    line.scale.z = 0.2;
                    continue;
                }
                if (c.userData.isSelecting) {
                    const tempM = new THREE.Matrix4().identity().extractRotation(c.matrixWorld);
                    raycaster.ray.origin.setFromMatrixPosition(c.matrixWorld);
                    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempM);
                    
                    const grabs = raycaster.intersectObjects(grabbableObjects, true);
                    if (grabs.length > 0) {
                        const hit = grabs[0];
                        line.scale.z = hit.distance;
                        line.material.color.setHex(0xffff00);
                        let objectToHighlight = hit.object;
                        while(objectToHighlight.parent && !grabbableObjects.includes(objectToHighlight) && objectToHighlight.parent !== scene) {
                             objectToHighlight = objectToHighlight.parent;
                        }
                        selectionBox.setFromObject(objectToHighlight);
                        selectionBox.visible = true;
                        continue;
                    } else {
                        line.material.color.setHex(0x00ffff);
                    }
                    const t = -raycaster.ray.origin.y / raycaster.ray.direction.y;
                    if (t > 0 && t < 15) {
                        marker.position.copy(raycaster.ray.origin).add(raycaster.ray.direction.multiplyScalar(t));
                        marker.visible = true; intersecting = true;
                        line.scale.z = t;
                    } else { line.scale.z = 5; }
                } else { c.getObjectByName('line').scale.z = 0; }
            }
            if (!intersecting) marker.visible = false;
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>