<!DOCTYPE html>
<html lang="en">
<head>
    <title>WebXR Video Stream</title>
    <meta charset="utf-g">
    <!-- This viewport is essential for WebXR and mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; 
            background-color: #000;
            color: #fff;
            overflow: hidden; /* Prevent scrolling */
        }
        #message-box {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            border-radius: 8px;
            z-index: 1000;
            display: none;
            font-size: 14px;
        }
        
        
        #OurVRButton {
            position: fixed !important;
            bottom: 30px !important; /* Raised it a bit */
            left: 50% !important;
            transform: translateX(-50%) !important;
            z-index: 9999 !important;
            
            /* Make it bigger and more obvious */
            padding: 16px 32px !important;
            background: #ffffff !important;
            color: #000000 !important;
            border: 2px solid #000 !important;
            border-radius: 12px !important;
            font-size: 18px !important;
            font-weight: bold !important;
            cursor: pointer !important;
            width: auto !important; /* Override default fixed width */
        }
    </style>
</head>
<body>
    <div id="message-box">Connecting to stream...</div>

    <script type="module">
        // --- FIX ---
        // We now import Three.js and VRButton as JavaScript modules.
        // This is much more reliable.
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/webxr/VRButton.js';
        // -----------

        let scene, camera, renderer;
        let videoCanvas, videoContext, videoTexture, videoScreen;

        // --- !! IMPORTANT !! ---
        // This should be your PC's IP address
        const YOUR_PC_IP = "192.168.1.24"; 
        // -----------------
        
        // This now correctly points to your PC's server
        const WEBSOCKET_URL = `ws://${YOUR_PC_IP}:8765`;
        
        // We can't know the frame size, so we'll start with a common one
        // and adjust it when the first frame arrives.
        const FRAME_WIDTH = 640;
        const FRAME_HEIGHT = 480;

        const msgBox = document.getElementById('message-box');
        let firstFrameReceived = false;

        function showMessage(msg) {
            msgBox.textContent = msg;
            msgBox.style.display = 'block';
        }

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222); // Dark background

            // Camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 1); // Start slightly back

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true; // Enable WebXR
            document.body.appendChild(renderer.domElement);

            // --- FIX ---
            // Get the button from the script, give it our ID, then add it
            const vrButton = VRButton.createButton(renderer);
            vrButton.id = "OurVRButton"; // Apply our custom ID
            document.body.appendChild(vrButton);
            // -----------

            // Create the "screen" to display the video
            
            // 1. Create an in-memory canvas to draw video frames on
            videoCanvas = document.createElement('canvas');
            videoCanvas.width = FRAME_WIDTH;
            videoCanvas.height = FRAME_HEIGHT;
            videoContext = videoCanvas.getContext('2d');
            videoContext.fillStyle = '#000000'; // Start with a black screen
            videoContext.fillRect(0, 0, FRAME_WIDTH, FRAME_HEIGHT);
            videoContext.fillStyle = 'white';
            videoContext.font = "30px Arial";
            videoContext.textAlign = "center";
            videoContext.fillText("Waiting for stream...", FRAME_WIDTH / 2, FRAME_HEIGHT / 2);


            // 2. Create a Three.js texture from that canvas
            videoTexture = new THREE.CanvasTexture(videoCanvas);

            // 3. Create the screen geometry (a simple plane)
            // --- EDIT: Made the screen 50% larger (3 units wide instead of 2) ---
            const screenGeometry = new THREE.PlaneGeometry(3, 3);

            // 4. Create the material using our video texture
            const screenMaterial = new THREE.MeshBasicMaterial({ 
                map: videoTexture,
                side: THREE.DoubleSide
            });

            // 5. Create the final mesh (the screen) and add it to the scene
            videoScreen = new THREE.Mesh(screenGeometry, screenMaterial);
            // --- EDIT: Pushed the screen back to -2.5m to make it comfortable ---
            videoScreen.position.set(0, 1.6, -2.5); // Position it in front of the user (X, Y, Z)
            scene.add(videoScreen);
            
            // Add a simple floor
            const floorGeo = new THREE.PlaneGeometry(10, 10);
            const floorMat = new THREE.MeshBasicMaterial({ color: 0x444444 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2; // Rotate to be flat
            floor.position.y = -0.5; // Position below the screen
            scene.add(floor);

            // Start the WebSocket connection
            connectWebSocket();

            // Start the animation loop
            renderer.setAnimationLoop(render);

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        function connectWebSocket() {
            showMessage(`Connecting to ${WEBSOCKET_URL}...`);
            const ws = new WebSocket(WEBSOCKET_URL);
            
            // We need an Image object to load the base64 data
            const img = new Image();
            img.onload = () => {
                // When the image loads, draw it to our hidden canvas
                
                // On the very first frame, resize canvas and screen
                if (!firstFrameReceived) {
                    firstFrameReceived = true;
                    videoCanvas.width = img.naturalWidth;
                    videoCanvas.height = img.naturalHeight;
                    
                    // Adjust the 3D plane's aspect ratio
                    // This logic still works: e.g., video is 16:9 (H/W = 0.5625)
                    // The plane is 3x3, so scale.y = 0.5625.
                    // Final plane is 3 wide by (3 * 0.5625) = 1.6875 tall. (Still 16:9)
                    const aspectRatio = img.naturalHeight / img.naturalWidth;
                    videoScreen.scale.y = aspectRatio;
                }

                videoContext.drawImage(img, 0, 0, videoCanvas.width, videoCanvas.height);
                // Tell Three.js that the texture needs to be updated
                videoTexture.needsUpdate = true;
            };

            ws.onopen = () => {
                showMessage("Stream connected!");
                setTimeout(() => { msgBox.style.display = 'none'; }, 2000);
            };

            ws.onmessage = (event) => {
                // When we get a message (a frame), set the image source.
                // This triggers the img.onload function above.
                img.src = 'data:image/jpeg;base64,' + event.data;
            };

            ws.onclose = () => {
                showMessage("Stream disconnected. Retrying in 3s...");
                firstFrameReceived = false; // Reset for re-connection
                
                // Draw a "disconnected" message on the canvas
                videoContext.fillStyle = '#222';
                videoContext.fillRect(0, 0, FRAME_WIDTH, FRAME_HEIGHT);
                videoContext.fillStyle = 'white';
                videoContext.font = "30px Arial";
                videoContext.textAlign = "center";
                videoContext.fillText("Disconnected", FRAME_WIDTH / 2, FRAME_HEIGHT / 2);
                videoTexture.needsUpdate = true;
                
                // Reset screen scale
                videoScreen.scale.y = 1.0;

                // Try to reconnect after 3 seconds
                setTimeout(connectWebSocket, 3000);
            };

            ws.onerror = (err) => {
                showMessage("Connection error. Check console and IP.");
                console.error("WebSocket Error:", err);
            };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function render() {
            // Render the scene
            renderer.render(scene, camera);
        }

        // Start everything
        init();

    </script>
</body>
</html>